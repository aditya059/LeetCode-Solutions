class Solution {
    bool solve(string &bottom, unordered_map<string, vector<string>> &allowedMap, int curr, string nextBottom) {
        if(bottom.length() == 1) {
            return true;
        }
        if(curr == bottom.length() - 1) {
            return solve(nextBottom, allowedMap, 0, "");
        }
        for(string allowedChar: allowedMap[bottom.substr(curr, 2)]) {
            if(solve(bottom, allowedMap, curr + 1, nextBottom + allowedChar)) {
                return true;
            }
        }
        return false;
    }
public:
    bool pyramidTransition(string bottom, vector<string>& allowed) {
        unordered_map<string, vector<string>> allowedMap;
        for(int i = 0; i < allowed.size(); i++) {
            allowedMap[allowed[i].substr(0, 2)].push_back(string(1, allowed[i][2])); 
        }
        return solve(bottom, allowedMap, 0, "");
    }
};
